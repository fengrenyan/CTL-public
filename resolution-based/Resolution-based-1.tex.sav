% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{booktabs}
\urlstyle{same}



\usepackage{setspace}
\usepackage{times}  %Required
\usepackage{helvet}  %Required
\usepackage{courier}  %Required
\usepackage{url}  %Required
%\usepackage{graphicx}  %Required

\usepackage{enumerate}


%\usepackage{algorithm}
%\usepackage{algorithmic}

\usepackage{amssymb}
\usepackage{enumerate}

\usepackage{subfigure}

\usepackage[linesnumbered,boxed,ruled,commentsnumbered]{algorithm2e}



\newcommand{\tuple}[1]{{\langle{#1}\rangle}}
\newcommand{\Mod}{\textit{Mod}}
\newcommand\ie{{\it i.e. }}
\newcommand\eg{{\it e.g.}}
%\newcommand\st{{\it s.t. }}
%\newtheorem{definition}{Definition}
%\newtheorem{examp}{Example}
%\newenvironment{example}{\begin{examp}\rm}{\end{examp}}
%\newtheorem{lemma}{Lemma}
%\newtheorem{proposition}{Proposition}
%\newtheorem{theorem}{Theorem}
%\newtheorem{corollary}[theorem]{Corollary}
%\newenvironment{proof}{{\bf Proof:}}{\hfill\rule{2mm}{2mm}\\ }
\newcommand{\rto}{\rightarrow}
\newcommand{\lto}{\leftarrow}
\newcommand{\lrto}{\leftrightarrow}
\newcommand{\Rto}{\Rightarrow}
\newcommand{\Lto}{\Leftarrow}
\newcommand{\LRto}{\Leftrightarrow}
\newcommand{\Var}{\textit{Var}}
\newcommand{\Forget}{\textit{Forget}}
\newcommand{\KForget}{\textit{KForget}}
\newcommand{\TForget}{\textit{TForget}}
%\newcommand{\forget}{\textit{forget}}
\newcommand{\Fst}{\textit{Fst}}
\newcommand{\dep}{\textit{dep}}
\newcommand{\term}{\textit{term}}
\newcommand{\literal}{\textit{literal}}

\newcommand{\Atom}{\mathcal{A}}
\newcommand{\SFive}{\textbf{S5}}
\newcommand{\MPK}{\textsc{k}}
\newcommand{\MPB}{\textsc{b}}
\newcommand{\MPT}{\textsc{t}}
\newcommand{\MPA}{\forall}
\newcommand{\MPE}{\exists}

\newcommand{\DNF}{\textit{DNF}}
\newcommand{\CNF}{\textit{CNF}}

\newcommand{\degree}{\textit{degree}}
\newcommand{\sunfold}{\textit{sunfold}}

\newcommand{\Pos}{\textit{Pos}}
\newcommand{\Neg}{\textit{Neg}}
\newcommand\wrt{{\it w.r.t.}}
\newcommand{\Hm} {{\cal M}}
\newcommand{\Hw} {{\cal W}}
\newcommand{\Hr} {{\cal R}}
\newcommand{\Hb} {{\cal B}}
\newcommand{\Ha} {{\cal A}}

\newcommand{\Dsj}{\triangledown}

\newcommand{\wnext}{\widetilde{\bigcirc}}
\newcommand{\nex}{\bigcirc}
\newcommand{\ness}{\square}
\newcommand{\qness}{\boxminus}
\newcommand{\wqnext}{\widetilde{\circleddash}}
\newcommand{\qnext}{\circleddash}
\newcommand{\may}{\lozenge}
\newcommand{\qmay}{\blacklozenge}
\newcommand{\unt} {{\cal U}}
\newcommand{\since} {{\cal S}}
\newcommand{\SNF} {\textit{SNF$_C$}}
\newcommand{\start}{\textbf{start}}
\newcommand{\Elm}{\textit{Elm}}
\newcommand{\simp}{\textbf{simp}}
\newcommand{\nnf}{\textbf{nnf}}

\newcommand{\CTL}{\textrm{CTL}}
\newcommand{\Ind}{\textrm{Ind}}
\newcommand{\Tran}{\textrm{Tran}}
\newcommand{\Sub}{\textrm{Sub}}
\newcommand{\NI}{\textrm{NI}}
\newcommand{\forget}{{\textsc{f}_\CTL}}
\newcommand{\ALL}{\textsc{a}}
\newcommand{\EXIST}{\textsc{e}}
\newcommand{\NEXT}{\textsc{x}}
\newcommand{\FUTURE}{\textsc{f}}
\newcommand{\UNTIL}{\textsc{u}}
\newcommand{\GLOBAL}{\textsc{g}}
\newcommand{\UNLESS}{\textsc{w}}
\newcommand{\Def}{\textrm{def}}
\newcommand{\IR}{\textrm{IR}}
\newcommand{\Tr}{\textrm{Tr}}
\newcommand{\dis}{\textrm{dis}}
\def\PP{\ensuremath{\textbf{PP}}}
\def\NgP{\ensuremath{\textbf{NP}}}
\def\W{\ensuremath{\textbf{W}}}
\newcommand{\Pre}{\textrm{Pre}}
\newcommand{\Post}{\textrm{Post}}


\newcommand{\CTLsnf}{{\textsc{SNF}_{\textsc{ctl}}^g}}
\newcommand{\ResC}{{\textsc{R}_{\textsc{ctl}}^{\succ, S}}}
\newcommand{\CTLforget}{{\textsc{F}_{\textsc{ctl}}}}
\newcommand{\Refine}{\textsc{Refine}}
\newcommand{\cf}{\textrm{cf.}}
\newcommand{\NEXP}{\textmd{\rm NEXP}}
\newcommand{\EXP}{\textmd{\rm EXP}}
\newcommand{\coNEXP}{\textmd{\rm co-NEXP}}
\newcommand{\NP}{\textmd{\rm NP}}
\newcommand{\coNP}{\textmd{\rm co-NP}}
\newcommand{\Pol}{\textmd{\rm P}}
\newcommand{\BH}[1]{\textmd{\rm BH}_{#1}}
\newcommand{\coBH}[1]{\textmd{\rm co-BH}_{#1}}
\newcommand{\Empty}{\varnothing}
\newcommand{\NLOG}{\textmd{\rm NLOG}}
\newcommand{\DeltaP}[1]{\Delta_{#1}^{p}}
\newcommand{\PIP}[1]{\Pi_{#1}^{p}}
\newcommand{\SigmaP}[1]{\Sigma_{#1}^{p}}

\begin{document}



%
\title{Contribution Title\thanks{Supported by organization x.}}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Renyan Feng\inst{1}\orcidID{0000-1111-2222-3333} \and
Erman Acar\inst{3}\orcidID{2222--3333-4444-5555} \and
Stefan Schlobach\inst{3}\orcidID{2222--3333-4444-5555} \and
Yisong Wang\inst{2,3}\orcidID{1111-2222-3333-4444}}
%
\authorrunning{F. Author et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Princeton University, Princeton NJ 08544, USA \and
Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
\email{lncs@springer.com}\\
\url{http://www.springer.com/gp/computer-science/lncs} \and
ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
\email{\{abc,lncs\}@uni-heidelberg.de}}
%


\maketitle              % typeset the header of the contribution
%
\begin{abstract}
This paper proved a method to computing the forgetting in \CTL\, which has been submitted to IJCAI, from the resolution proposed by Zhang at all by extending the resolution rules.

\keywords{Forgetting  \and CTL \and Model checking.}
\end{abstract}

\section{Introduction}
As a logical notion, \emph{forgetting} was first formally defined
in propostional and first order logics by Lin and Reiter~\cite{lin1994forget}.
Over the last twenty years, researchers have developed forgetting notions and theories not only in classical logic but also in other non-classical logic systems~\cite{eiter2019brief}, such as forgetting in logic programs under answer set/stable model semantics~\cite{DBLP:Zhang:AIJ2006,Eiter2008Semantic,Wong:PhD:Thesis,Yisong:KR:2012,Yisong:IJCAI:2013}, forgetting in description logic~\cite{Wang:AMAI:2010,Lutz:IJCAI:2011,zhao2017role} and knowledge forgetting in modal logic~\cite{Yan:AIJ:2009,Kaile:JAIR:2009,Yongmei:IJCAI:2011,fang2019forgetting}. In application, forgetting has been used in planning~\cite{lin2003compiling},  conflict solving \cite{Lang2010Reasoning,Zhang2005Solving},
%knowledge compilation \cite{Zhang2009Knowledge,Bienvenu2010Knowledge},
createing restricted views of ontologies~\cite{zhao2017role},
%{ZhaoSchmidt18a},
strongest and weakest definitions \cite{Lang2008On}, SNC (WSC) \cite{DBLP:journals/ai/Lin01} and so on.


Though forgetting has been extensively investigated from various aspects of different logical systems.
However, the existing forgetting method in propositional
logic, answer set programming, description logic and modal logic are not directly applicable in \CTL.
Similar with that in~\cite{Yan:AIJ:2009}, we research forgetting in \CTL\ from the semantic forgetting point of view.
And it is shown that our definition of forgetting satisfies those four postulates of forgetting.
%
%
\section{Preliminaries}
We start with some technical and notational preliminaries. Throughout this paper, we fix a finite set $\Ha$ of propositional variables (or atoms), and use $V$, $V'$ for subsets of $\Ha$. In the following several parts, we will introduce the structure we use for \CTL, syntactic and semantic of \CTL\ and the normal form $\CTLsnf$ (Separated Normal Form with Global Clauses for \CTL) of \CTL~\cite{zhang2009refined}.
\subsection{Model structure in \CTL}
 In general, a transition system~\footnote{According to \cite{Baier:PMC:2008},
a {\em transition system} TS is a tuple $(S, Act,\rto,I, AP, L)$ where
(1) $S$ is a set of states,
(2) $\textrm{Act}$ is a set of actions,
(3) $\rto\subseteq S\times \textrm{Act}\times S$ is a transition relation,
(4) $I\subseteq S$ is a set of initial states,
(5) $\textrm{AP}$ is a set of atomic propositions, and
(6) $L:S\rto 2^{\textrm{AP}}$ is a labeling function.} is described as a \emph{model\ structure} (or \emph{Kripke \ structure})(in this article, we treat transition system and model structure as the same thing), and a model structure is a triple $\Hm=(S,R,L)$~\cite{emerson1990temporal}, where
\begin{itemize}
  \item $S$ is a set of states,
  \item $R\subseteq S\times S$ is a total binary relation over $S$, \ie, for each state $s\in S$ there is a state $s'\in S$ such that $(s,s')\in R$, and
  \item $L$ is an interpretation function $S\rto 2^{\cal A}$ mapping every state to the set of atoms true at that state.
\end{itemize}
In this article, the same as~\cite{DBLP:journals/tcs/BrowneCG88}, all of our results apply only to finite Kripke structures.
Besides, we restrict ourselves to model structure $\Hm=(S,R,L,s_0)$ (similar with that in~\cite{zhang2009refined}) such that
\begin{itemize}
  \item there exists a state $s_0$, called the \emph{initial\ state}, such that for every state $s\in S$ there is a path $\pi_{s_0}$ s.t. $s\in \pi_{s_0}$.
\end{itemize}
We call a model structure $\Hm$ on a set $V$ of atoms if $L: S \rto 2^V$, \ie, the labeling function $L$ map every state to $V$ (not the $\Ha$).  A \emph{path} $\pi_{s_i}$ start from $s_i$ of $\Hm$ is a infinite sequence of states $\pi_{s_i}=(s_i, s_{i+1} s_{i+2},\dots)$, where for each $j$ ($i\leq j$), $(s_j, s_{j+1}) \in R$. By $s'\in \pi_{s_i}$ we mean that $s'$ is a state in the path $\pi_{s_i}$.

For a given model structure $(S,R,L,s_0)$ and $s\in S$,
the {\em computation tree}
$\Tr_n^{\cal M}(s)$ of $\cal M$(or simply $\Tr_n(s)$), that has depth $n$ and is rooted at $s$, is recursively defined as~\cite{DBLP:journals/tcs/BrowneCG88}, for $n\ge 0$,
\begin{itemize}
  \item $\Tr_0(s)$ consists of a single node $s$ with label $s$.
  \item $\Tr_{n+1}(s)$ has as its root a node $m$ with label  $s$, and
  if $(s,s')\in R$ then the node $m$ has a subtree $\Tr_n(s')$\footnote{Though
  some nodes of the tree may have the same label, they are different nodes in the tree.}.
\end{itemize}
By $s_n$ we mean the node at the $n$th level in tree $\Tr_m(s)$ $(m \geq n)$.

A {\em \MPK-structure} (or {\em \MPK-interpretation}) is a model structure
${\cal M}=(S, R, L, s_0)$ associating
with a state $s\in S$, which is written as $({\cal M},s)$ for convenience in the following.
In the case $s$ is an initial state of $\cal M$, the \MPK-structure is {\em initial}.


\subsection{Syntactic and semantic of \CTL}
In the following we briefly review the basic syntax and semantics
of the {\em Computation Tree Logic}
(\CTL\ in short)~\cite{DBLP:journals/toplas/ClarkeES86}. %Huth:BOOK:1999}.
%In  $\cal L$, the model of time is a tree-like structure in which the future is not
%determined; there are different paths in the future, any one of which might
%be the `actual' path that is realized.
%
The {\em signature} of $\cal L$ includes:
\begin{itemize}
  \item a finite set of Boolean variables, called {\em atoms} of $\cal L$: $\cal A$;
  \item the classical connectives: $\bot,\lor$ and $\neg$;
  \item the path quantifiers: $\ALL$ and $\EXIST$;
  \item the temporal operators: \NEXT, \FUTURE, \GLOBAL\, \UNTIL\ and \UNLESS, that
  means `neXt state', `some Future state', `all future states (Globally)', `Until' and `Unless', respectively;
  \item parentheses: ( and ).
\end{itemize}

The {\em (existential normal form or ENF in short) formulas} of
$\cal L$ are inductively defined via a Backus Naur form:
\begin{equation}\label{def:CTL:formulas}
  \phi ::= \bot\mid p \mid\neg\phi \mid \phi\lor\phi \mid
    \EXIST \NEXT \phi \mid
    %\EXIST \FUTURE \phi \mid
    \EXIST \GLOBAL \phi \mid
    \EXIST [\phi\ \UNTIL\ \phi]%.% \mid
    %\ALL \NEXT \phi \mid
%    \ALL \FUTURE \phi \mid
%    \ALL \GLOBAL \phi \mid
%    \ALL [\phi\ \UNTIL\ \phi]
\end{equation}
where $p\in\cal A$. The formulas $\phi\land\psi$ and $\phi\rto\psi$
are defined in a standard manner of propositional logic.
%Intuitively,
%the formula $\EXIST\NEXT\phi$ means that $\phi$ holds in some immediate successor
%of the current program state; the formula $\EXIST\GLOBAL\phi$ means
%that for some computation path $\phi$ holds at every state along the path; and the
%formula $\EXIST[\phi\UNTIL\psi]$ means that
%for some computation path there is an initial prefix of the path such
%that $\psi$ holds at the last state of the prefix  and $\phi$ holds at all other
%states along the prefix.
The other form formulas of $\cal L$ are abbreviated
using the forms of (\ref{def:CTL:formulas}).
%\begin{align*}
%  & \top =_{\Def} \neg\bot,\\
%  & \ALL [\phi\ \UNTIL\ \psi] =_{\Def}
%    \neg(\EXIST[\neg\psi\UNTIL \left(\neg \phi\land\neg\psi)]\lor\EXIST\GLOBAL\neg\psi\right),\\
%  & \ALL\FUTURE\phi=_{\Def}   \ALL [\top \UNTIL\ \phi],\\
%  & \EXIST\FUTURE\phi=_{\Def}\EXIST[\top\UNTIL\phi],\\
%  & \ALL\GLOBAL\phi =_{\Def} \neg\EXIST\FUTURE\neg\phi,\\
%  & \ALL\NEXT\phi =_{\Def} \neg\EXIST\NEXT\neg\phi,\\
%  & \ALL(\varphi \UNLESS \psi) =_{\Def} \neg \EXIST(\neg \psi \UNTIL (\neg \varphi \wedge \neg \psi)),\\
%  & \EXIST (\varphi \UNLESS \psi) =_{\Def} \neg \ALL(\neg \psi \UNTIL (\neg \varphi \wedge \neg \psi)).
%\end{align*}
Notice that, according to the
above definition for formulas of \CTL,
each of the \CTL\ {\em temporal connectives} has the form $XY$
where $X\in \{\ALL,\EXIST\}$ and  $Y\in\{\NEXT, \FUTURE, \GLOBAL, \UNTIL, \UNLESS\}$.
 %
The priorities for the \CTL\ connectives are assumed to be (from the highest to the lowest):
\begin{equation*}
  \neg, \EXIST\NEXT, \EXIST\FUTURE, \EXIST\GLOBAL, \ALL\NEXT, \ALL\FUTURE, \ALL\GLOBAL
  \prec \land \prec \lor \prec \EXIST\UNTIL, \ALL\UNTIL, \EXIST \UNLESS, \ALL \UNLESS, \rto.
\end{equation*}

We are now in the position to define the semantics of $\cal L$.
Let ${\cal M}=(S,R,L,s_0)$ be an model structure, $s\in S$ and $\phi$ a formula of $\cal L$.
The {\em satisfiability} relationship between ${\cal M},s$ and $\phi$,
written $({\cal M},s)\models\phi$, is inductively defined on the structure of $\phi$ as follows:
\begin{itemize}
  \item $({\cal M},s)\not\models\bot$;
  \item $({\cal M},s)\models p$ iff $p\in L(s)$;
  \item $({\cal M},s)\models \phi_1\lor\phi_2$ iff
    $({\cal M},s)\models \phi_1$ or $({\cal M},s)\models \phi_2$;
  \item $({\cal M},s)\models \neg\phi$ iff  $({\cal M},s)\not\models\phi$;
  \item $({\cal M},s)\models \EXIST\NEXT\phi$ iff
    $({\cal M},s_1)\models\phi$ for some $s_1\in S$ and $(s,s_1)\in R$;
  \item $({\cal M},s)\models \EXIST\GLOBAL\phi$ iff
    $\cal M$ has a path $(s_1=s,s_2,\ldots)$ such that
    $({\cal M},s_i)\models\phi$ for each $i\ge 1$;
  \item $({\cal M},s)\models \EXIST[\phi_1\UNTIL\phi_2]$ iff
    $\cal M$ has a path $(s_1=s,s_2,\ldots)$ such that, for some $i\ge 1$,
    $({\cal M},s_i)\models\phi_2$ and
    $({\cal M},s_j)\models\phi_1$ for each $j<i$.
\end{itemize}

Similar to the work in \cite{DBLP:journals/tcs/BrowneCG88,Bolotov:1999:JETAI},
only initial \MPK-structures are considered to be candidate models
in the following, unless explicitly stated. Formally,
an initial \MPK-structure $\cal K$ is a {\em model} of a formula $\phi$
whenever ${\cal K}\models\phi$.
Let $\Pi$ be a set of formulae, ${\cal K} \models \Pi$ if for each $\phi\in \Pi$ there is $\cal K \models \phi$.
We denote $\Mod(\phi)$  ($\Mod(\Pi)$) the set of models of $\phi$ ($\Pi$).
The formula $\phi$ (set $\Pi$ of formulae) is {\em satisfiable}
if $\Mod(\phi)\neq\emptyset$ ($\Mod(\Pi)\neq\emptyset$).
Since both the underlying states in model structure and signatures are finite, $\Mod(\phi)$ ($\Mod(\Pi)$)
is finite for any formula $\phi$ (set $\Pi$ of formulae).

Let $\phi_1$ and $\phi_2$ be two formulas or set of formulas.
By $\phi_1\models\phi_2$ we denote $\Mod(\phi_1)\subseteq\Mod(\phi_2)$.
By $\phi_1\equiv\phi_2$ we mean $\phi_1\models\phi_2$ and $\phi_2\models\phi_1$.
In this case $\phi_1$ is {\em equivalent} to $\phi_2$.

Let $\phi$ be a formula or set of formulas. By $\Var(\phi)$ we mean the set of atoms occurring in $\phi$.
Let $V\subseteq\cal A$.
The formula $\phi$ is $V$-{\em irrelevant}, written $\IR(\phi,V)$,
if there is a formula $\psi$ with
$\Var(\psi)\cap V=\emptyset$ such that $\phi\equiv\psi$.


\subsection{The normal form of \CTL}
It has proved that any \CTL\ formula $\varphi$ can be transformed into a set $T_\varphi$ of $\CTLsnf$ (Separated Normal Form with Global Clauses for \CTL) clauses in polynomial time such that $\varphi$ is satisfiable iff $T_\varphi$ is satisfiable~\cite{zhang2008first}.
An important difference between \CTL\ formulae and $\CTLsnf$ is that $\CTLsnf$ is an extension of the syntax of \CTL\ to use indices. These indices can be used to preserve a particular path context. The language of $\CTLsnf$ clauses is defined over an extension of \CTL. That is the language is based on: (1) the language of CTL; (2) a propositional constant $\start$; (3) a countably infinite index set $\Ind$; and (4) temporal operators: $\EXIST_{\tuple{ind}} \NEXT$, $\EXIST_{\tuple{ind}} \FUTURE$, $\EXIST_{\tuple{ind}} \GLOBAL$,$\EXIST_{\tuple{ind}} \UNTIL$ and $\EXIST_{\tuple{ind}} \UNLESS$.

The priorities for the $\CTLsnf$\ connectives are assumed to be (from the highest to the lowest):
\begin{align*}
  &\neg, (\EXIST\NEXT,\EXIST_{\tuple{ind}}\NEXT), (\EXIST\FUTURE ,\EXIST_{\tuple{ind}}\FUTURE), (\EXIST\GLOBAL,\EXIST_{\tuple{ind}} \GLOBAL), \ALL\NEXT, \ALL\FUTURE, \ALL\GLOBAL \\
  &\prec \land \prec \lor \prec (\EXIST\UNTIL,\EXIST_{\tuple{ind}} \UNTIL), \ALL\UNTIL, (\EXIST \UNLESS, ,\EXIST_{\tuple{ind}}\UNLESS), \ALL \UNLESS, \rto.
\end{align*}
Where the operators in the same brackets have the same priority.

%The $\CTLsnf$ clauses consists of formulae of the following forms: $\ALL \GLOBAL(\start \supset \bigvee_{j=1}^k m_j)$ (initial clause), $\ALL \GLOBAL(true \supset \bigvee_{j=1}^k m_j)$ (global clause), $\ALL \GLOBAL(\bigwedge_{i=1}^n l_i \supset \ALL \NEXT \bigvee_{j=1}^k m_j)$ (\ALL-step clause), $\ALL \GLOBAL(\bigwedge_{i=1}^n l_i \supset \EXIST_\tuple{ind} \NEXT \bigvee_{j=1}^k m_j)$ (\EXIST-step clause), $\ALL \GLOBAL(\bigwedge_{i=1}^n l_i \supset \ALL \FUTURE l)$ (\ALL-sometime clause) and $\ALL \GLOBAL(\bigwedge_{i=1}^n l_i \supset \EXIST_{\tuple{ind}} \FUTURE l)$ (\EXIST-sometime clause),
Before talked about the sematic of this language, we introduce the $\CTLsnf$ clauses at first. The $\CTLsnf$ clauses consists of formulae of the following forms.
\begin{align*}
& \ALL \GLOBAL(\start \supset \bigvee_{j=1}^k m_j) && (initial\ clause) \\
& \ALL \GLOBAL(true \supset \bigvee_{j=1}^k m_j) && (global\ clause) \\
& \ALL \GLOBAL(\bigwedge_{i=1}^n l_i \supset \ALL \NEXT \bigvee_{j=1}^k m_j) && (\ALL-step\ clause)\\
& \ALL \GLOBAL(\bigwedge_{i=1}^n l_i \supset \EXIST_\tuple{ind} \NEXT \bigvee_{j=1}^k m_j) && (\EXIST-step\ clause)\\
& \ALL \GLOBAL(\bigwedge_{i=1}^n l_i \supset \ALL \FUTURE l) && (\ALL-sometime\ clause)\\
& \ALL \GLOBAL(\bigwedge_{i=1}^n l_i \supset \EXIST_{\tuple{ind}} \FUTURE l) && (\EXIST-sometime\ clause).
\end{align*}
where $k \ge 0$, $n > 0$, $\start$ is a propositional constant, $l_i$ ($1 \le i \le n$), $m_j$ ($1 \le j \le k$) and $l$ are literals, that is atomic propositions or their negation and ind is an element of Ind (Ind is a countably infinite index set). By clause we mean the classical clause or the $\CTLsnf$ clause unless explicitly stated.
 %A set $T$ of $\CTLsnf$ clauses is satisfiable if there is a model $\Hm=(S, R, L, [\_], s_0)$ \st\ for all clause $C\in T$, $(\Hm, s_0) \models C$.

Formulae of $\CTLsnf$ over $\Ha$ are interpreted in \Ind-model structure $\Hm=(S,R,L, [\_], s_0)$, where $S$, $R$, $L$ and $s_0$ is the same as our model structure talked in 2.1 and $[\_]: \Ind \rto 2^{(S*S)}$ maps every index $ind \in \Ind$ to a successor function $[ind]$ which is a functional relation on $S$ and a subset of the binary accessibility relation $R$, such that for every $s\in S$ there exists exactly a state $s'\in S$ such that $(s,s')\in [ind]$ and $(s,s')\in R$.
%In this paper we do not need a strict tree model structure as in~\cite{zhang2009refined}, that is we do not those restrictions on $s_0$ due to that only for simplifying the proof but do not impact the satisfiability of a formula~\cite{zhang2009refined}.
An infinite path $\pi_{s_i}^{\tuple{ind}}$ is an infinite sequence of states $s_i, s_{i+1}, s_{i+2},\dots$ such that for every $j\geq i$, $(s_j, s_{j+1})\in [ind]$.
%Let $\pi$ be a path in \Ind-model structure $\Hm$, by $s\in \pi$ we mean that $s$ is a state in the path $\pi$.

Similarly, an {\em \Ind-structure} (or {\em \Ind-interpretation}) is a \Ind-model structure
${\cal M}=(S, R, L, [\_], s_0)$ associating
with a state $s\in S$, which is written as $({\cal M},s)$ for convenience in the following.
In the case $s$ is an initial state of $\cal M$, the \Ind-structure is {\em initial}.

The semantics of $\CTLsnf$ is an extension of the semantics of \CTL\ defined in Section 2.2 except using the \Ind-model structure $\Hm=(S,R,L,[\_],s_0)$ replace model structure, $({\cal M},s_i) \models \start$ iff $s_i=s_0$ and for all $\EXIST_{\tuple{ind}} \Gamma$ are explained in the path $\pi_{s_i}^{\tuple{ind}}$, where $\Gamma\in \{\NEXT, \GLOBAL, \UNTIL,\UNLESS\}$.
The semantics of $\CTLsnf$ is then
defined as shown next as an extension of the semantics of CTL defined in Section 2.2. Let $\varphi$ and $\psi$ be two $\CTLsnf$ formulae and $\Hm=(S,R,L,[\_],s_0)$ be an \Ind-model structure, the relation ``$\models$" between $\CTLsnf$ formulae and $\Hm$ is defined recursively as follows:
\begin{itemize}
  \item $({\cal M},s_i) \models \start$ iff $s_i=s_0$;
  \item $({\cal M},s_i)\models \EXIST_{\tuple{ind}} \NEXT \psi$ iff for the path $\pi_{s_i}^{\tuple{ind}}$, $(\Hm, s_{i+1})\models \psi$;
  \item $({\cal M},s_i)\models \EXIST_{\tuple{ind}}\GLOBAL\psi$ iff
    for every $s_j \in \pi_{s_i}^{\tuple{ind}}$,
    $(\Hm,s_j) \models \psi$;
  \item $({\cal M},s_i)\models \EXIST_{\tuple{ind}}[\varphi\UNTIL\psi]$ iff
      there exists $s_j\in \pi_{s_i}^{\tuple{ind}}$ such that $(\Hm,s_j) \models \psi$ and for every $s_k \in \pi_{s_i}^{\tuple{ind}}$, if $i\leq k < j$, then $(\Hm,s_k) \models \varphi$;
  \item $(\Hm,s_i) \models \EXIST_{\tuple{ind}} \FUTURE \psi$ iff $(\Hm,s_i) \models \EXIST_{\tuple{ind}}[\top \UNTIL\psi]$;
  \item $({\cal M},s_i)\models \EXIST_{\tuple{ind}}[\varphi\UNLESS\psi]$ iff $(\Hm,s_i) \models \EXIST_{\tuple{ind}}\GLOBAL \varphi$ or $({\cal M},s_i)\models \EXIST_{\tuple{ind}}[\varphi\UNTIL\psi]$.
\end{itemize}
The semantics of the remaining operators is analogous to that given previously but in the
extended \Ind-model structure ${\cal M}=(S, R, L, [\_],s_0)$.
A $\CTLsnf$ formula $\varphi$ is satisfiable, iff for some \Ind-model structure $\Hm=(S,R,L,[\_],s_0)$, $(\Hm,s_0)\models \varphi$, and unsatisfiable otherwise. And if $(\Hm,s_0)\models \varphi$ then $(\Hm,s_0)$ is called a \Ind-model of $\varphi$, and we say that $(\Hm,s_0)$ satisfies $\varphi$.
By $T \wedge \varphi$ we mean $\bigwedge_{\psi\in T} \psi \wedge \varphi$, where $T$ is a set of formulae.
Other terminologies are similar with those in section 2.2.




\section{Problem Definition}
In order to define our problem, \ie forgetting in \CTL, we review our definition of $V$-bisimulation (read ?? for more detials).
\begin{definition}\label{def:Vbi}
Let $V\subseteq\cal A$
%${\cal M}_i=(S_i,R_i,L_i,s_0^i)~(i=1,2)$ be model structures
and ${\cal K}_i=({\cal M}_i,s_i)~(i=1,2)$ be \MPK-structures (Ind-structures).
Then $({\cal K}_1,{\cal K}_2)\in\cal B$ if and only if
  \begin{enumerate}[(i)]
    \item $L_1(s_1)- V = L_2(s_2)-V$,
    \item for every $(s_1,s_1')\in R_1$, there is $(s_2,s_2')\in R_2$
    such that $({\cal K}_1',{\cal K}_2')\in \Hb$, and
    \item for every $(s_2,s_2')\in R_2$, there is $(s_1,s_1')\in R_1$
%    such that $({\cal K}_1',{\cal K}_2')\in \Hb$,
   \end{enumerate}
 where ${\cal K}_i'=({\cal M}_i,s_i')$ with $i\in\{1,2\}$.
\end{definition}

\begin{proposition}\label{div}
Let $i\in \{1,2\}$, $V_1,V_2\subseteq\cal A$, $s_i'$s be two states and
  $\pi_i'$s be two pathes,
and ${\cal K}_i=({\cal M}_i,s_i)~(i=1,2,3)$ be \MPK-structures (Ind-structures)
 such that
${\cal K}_1\lrto_{V_1}{\cal K}_2$ and ${\cal K}_2\lrto_{V_2}{\cal K}_3$.
 Then:
 \begin{enumerate}[(i)]
   \item $s_1'\lrto_{V_i}s_2'~(i=1,2)$ implies $s_1'\lrto_{V_1\cup V_2}s_2'$;
   \item $\pi_1'\lrto_{V_i}\pi_2'~(i=1,2)$ implies $\pi_1'\lrto_{V_1\cup V_2}\pi_2'$;
   \item for each path $\pi_{s_1}$ of $\Hm_1$ there is a path $\pi_{s_2}$  of $\Hm_2$ such that $\pi_{s_1} \lrto_{V_1} \pi_{s_2}$, and vice versa;
   \item ${\cal K}_1\lrto_{V_1\cup V_2}{\cal K}_3$;
   \item If $V_1 \subseteq V_2$ then ${\cal K}_1 \lrto_{V_2} {\cal K}_2$.
 \end{enumerate}
\end{proposition}

Now we give the formal definition of forgetting in \CTL\ from the semantic forgetting point view.
\begin{definition}[Forgetting]\label{def:V:forgetting}
  Let $V\subseteq\cal A$ and $\phi$ a \CTL\ formula.
A \CTL\ formula $\psi$ with $\Var(\psi)\cap V=\emptyset$
is a {\em result of forgetting $V$ from} $\phi$, if
\begin{equation}
  \Mod(\psi)=\{{\cal K}\mbox{ is initial}\mid \exists {\cal K}'\in\Mod(\phi)\ \&\ {\cal K}'\lrto_V{\cal K}\}.
\end{equation}
Where $\cal K$ and ${\cal K}'$ are $\MPK$-structures.
\end{definition}
Note that if both $\psi$ and $\psi'$ are results of forgetting $V$ from $\phi$ then
$\Mod(\psi)=\Mod(\psi')$, \ie, $\psi$ and $\psi'$ have the same models. In the sense
of equivalence the forgetting result is unique (up to equivalence).


Similar with the $V$-bisimulation between \MPK-structures, we define the $\tuple{V,I}$-bisimulation between \Ind-structures as follows:
\begin{definition}\label{def:VInd:bisimulation}
\textbf{($\tuple{V,I}$-bisimulation)}
Let $\Hm_i=(S_i, R_i, L_i, [\_]_i, s_0^i)$ with $i\in \{1, 2\}$ be two \Ind-structures, $V$ be a set of atoms and $I \subseteq Ind$. The $\tuple{V,I}$-bisimulation $\beta_{\tuple{V,I}}$ between initial \Ind-structures is a set that satisfy $((\Hm_1, s_0^1), (\Hm_2, s_0^2)) \in \beta_{\tuple{V,I}}$  if and only if $(\Hm_1, s_0^1) \lrto_V (\Hm_2, s_0^2)$ and $\forall j \notin I$ there is
\begin{enumerate}[(i)]
  \item $\forall (s, s_1)\in [j]_1$ there is $(s',s_1')\in [j]_2$ such that $s\lrto_V s'$ and $s_1 \lrto_V s_1'$, and
  \item $\forall (s', s_1')\in [j]_2$ there is $(s,s_1)\in [j]_1$ such that $s\lrto_V s'$ and $s_1 \lrto_V s_1'$.
\end{enumerate}
%$\forall j \notin I$ there is $[j]_1 = [j]_2$.
\end{definition}
Apparently, this definition is similar with our concept $V$-bisimulation except that this $\tuple{V,I}$-bisimulation has introduced the index.
%Besides, it is not difficult to prove $\tuple{V,I}$-bisimulation possess those properties (talked-above) possessed by $V$-bisimulation.

\begin{proposition}\label{pro:VI:div}
Let $i\in \{1,2\}$, $V_1,V_2\subseteq\cal A$, $I_1, I_2 \subseteq Ind$
and ${\cal K}_i=({\cal M}_i,s_0^i)~(i=1,2,3)$ be Ind-structures
 such that
${\cal K}_1\lrto_{\tuple{V_1, I_1}}{\cal K}_2$ and ${\cal K}_2\lrto_{\tuple{V_2,I_2}}{\cal K}_3$.
 Then:
 \begin{enumerate}[(i)]
  % \item $s_1'\lrto_{V_i}s_2'~(i=1,2)$ implies $s_1'\lrto_{V_1\cup V_2}s_2'$;
%   \item $\pi_1'\lrto_{V_i}\pi_2'~(i=1,2)$ implies $\pi_1'\lrto_{V_1\cup V_2}\pi_2'$;
%   \item for each path $\pi_{s_1}$ of $\Hm_1$ there is a path $\pi_{s_2}$  of $\Hm_2$ such that $\pi_{s_1} \lrto_{V_1} \pi_{s_2}$, and vice versa;
   \item ${\cal K}_1\lrto_{\tuple{V_1\cup V_2, I_1 \cup I_2}}{\cal K}_3$;
   \item If $V_1 \subseteq V_2$ and $I_1 \subseteq I_2$ then ${\cal K}_1 \lrto_{\tuple{V_2, I_2}} {\cal K}_2$.
 \end{enumerate}
\end{proposition}
\begin{proof}
%This can be proved similarly with Proposition~\ref{div}.
(i) By Proposition~\ref{div} we have ${\cal K}_1\lrto_{V_1\cup V_2}{\cal K}_3$. For (i) of Definition~\ref{def:VInd:bisimulation} we can prove it as follows:
$\forall (s,s_1) \in [j]_1$ there is a $(s', s_1') \in [j]_2$ such that $s\lrto_{V_1} s'$ and $s_1 \lrto_{V_1} s_1'$ and there is a $(s'', s_1'') \in [j]_3$ such that $s'\lrto_{V_2} s''$ and $s_1' \lrto_{V_2} s_1''$, and then we have $\forall (s,s_1) \in [j]_1$ there is a $(s'', s_1'') \in [j]_3$ such that $s  \lrto_{V_1\cup V_2} s''$ and $s_1 \lrto_{V_1\cup V_2} s_1''$. The (ii) of Definition~\ref{def:VInd:bisimulation} can be proved similarly.

(ii) This can be proved from (i).
\end{proof}



\section{The Calculus}
\emph{Resolution} in \CTL\ is a method to decide the satisfiability of a \CTL\ formula.
In this paper, we will explore a resolution-based method to compute forgetting in \CTL.
In this part we use the transformation rules Trans(1) to Trans(12) and resolution rules (SRES1), \dots, (SRES8), RW1, RW2, (ERES1), (ERES2) in~\cite{zhang2009refined}.

The key problems of this method include (1) How to fill the gap between \CTL\ and $\CTLsnf$; and (2) How to eliminate the irrelevant atoms in the formula.
We will resolve these two problems by $\tuple{V,I}$-bisimulation and \emph{substitution} operator.
For convenient, we use $V\subseteq \Ha$ denote the set we want to forget, $V' \subseteq \Ha$ with $V \cap V'={\O}$ the set of atoms ($I$ be the set of index) introduced in the transformation process, $\varphi$  the \CTL\ formula, $T_{\varphi}$ be the set of $\CTLsnf$ clause obtained from $\varphi$ by using transformation rules  and $\Hm=(S,R,L,[\_], s_0)$ unless explicitly stated.
 Let $T$, $T'$ be two set of formulae, $I$ a set of indexes and $V''\subseteq \Ha$, by $T\equiv_{\tuple{V'', I}} T'$ we mean that $\forall (\Hm, s_0) \in \Mod(T)$ there is a $(\Hm', s_0')$ such that $(\Hm,s_0) \lrto_{\tuple{V'', I}} (\Hm',s_0')$ and $(\Hm', s_0') \models T'$ and vice versa.


\begin{proposition}\label{pro:In2NI}
Let $P$, $P_i$ and $\varphi_i$ be \CTL\ formulas, then
\begin{enumerate}[(i)]
  \item $P\supset \EXIST_{\tuple{ind}} \NEXT \varphi_1 \wedge \dots \wedge P\supset \EXIST_{\tuple{ind}}\NEXT \varphi_n  \equiv_{\tuple{\emptyset, \{ind\}}} P\supset \EXIST \NEXT \bigwedge_{i\in \{0,\dots, n\}}\varphi_i$,
  \item $P_1\supset \EXIST_{\tuple{ind}} \NEXT \varphi_1 \wedge \dots \wedge P_n\supset \EXIST_{\tuple{ind}}\NEXT \varphi_n \in T \equiv_{\tuple{\emptyset, \{ind\}}} \bigwedge_{e \in 2^{\{0,\dots, n\}} \setminus \{\emptyset\}}(\bigwedge_{i\in e}P_i\supset \EXIST \NEXT (\bigwedge_{i\in e}\varphi_i))$,
  \item $P\supset \EXIST_{\tuple{ind}} \FUTURE \varphi_1 \wedge \dots \wedge P\supset \EXIST_{\tuple{ind}} \FUTURE \varphi_n \in T \equiv_{\tuple{\emptyset, \{ind\}}} P\supset \bigvee\EXIST\FUTURE (\varphi_{j_1} \wedge \EXIST\FUTURE(\varphi_{j_2} \wedge \EXIST\FUTURE(\dots \wedge \EXIST\FUTURE \varphi_{j_n})))$, where $(j_1, \dots, j_n)$ are sequences of all elements in $\{0, \dots, n\}$,
  \item $P\supset (C \vee \EXIST_{\tuple{ind}} \NEXT \varphi_1) \wedge P \supset \EXIST_{\tuple{ind}} \NEXT \varphi_2 \equiv_{\tuple{\emptyset, \{ind\}}} P \supset ((C \wedge \EXIST \NEXT \varphi_2) \vee \EXIST \NEXT (\varphi_1 \wedge \varphi_2))$
\end{enumerate}
\end{proposition}
\begin{proof}
It is easy to check.
\end{proof}

The algorithm of computing the forgetting in \CTL\ is as Algorithm~\ref{alg:compute:forgetting:by:Resolution}.
The main idea of this algorithm is to change the \CTL\ formula into a set of $\CTLsnf$ clauses at first (the Tran process), and then compute all the possible resolutions on the specified set of atoms (the Res process), eliminate all the irrelevant atoms which dose not be removed by the resolution. We will describe this process in detail below (the Sub, EF, Elm and R processes).
\begin{algorithm}[!h]
\caption{Computing forgetting - A resolution-based method}% ??????
\label{alg:compute:forgetting:by:Resolution}
%\LinesNumbered %?????????
\KwIn{A CTL formula $\varphi$ and a set $V$ of atoms}% ????????
\KwOut{$\CTLforget(\varphi, V)$}% ????
$T={\O}$ // the initial set of $\CTLsnf$ clauses of $\varphi$ \;
$T' = {\O}$ // the set of $\CTLsnf$ clauses without index\;
$V'={\O}$ // the set of atoms introduced in the process of transforming $\varphi$ into $\CTLsnf$ clauses\;


$T, V' \lto Tran(\varphi, V)$\;

$Res \lto Res(T, V')$\;

$\Gamma \lto \Sub(Res, V')$\;
%$\Gamma_1 = \Elm(\Gamma, \Gamma)$\;
%Using distribution law by viewing each $\CTLsnf$ as an atom to change $\Gamma_1$ into a set $L$ of sets of $\CTLsnf$; // from $(a \vee b) \wedge c$ to $(a \wedge c) \vee (b \wedge c)$\;
%$L'=R(\NI(L)_{\CTL})$\;
%\Return $\bigwedge_{\psi \in L'} \psi$.
%Let $\Omega$, which obtained from $\Elm(\EXIST\FUTURE(\Gamma), \Gamma)$ by using distribution law by viewing each $\CTLsnf$ clause as an atom, be a set of sets of $\CTLsnf$ clauses.\;

$\Omega\lto \Elm(\EXIST\FUTURE(\Gamma), \Gamma)$\;
$\Gamma_1\lto \NI(\Omega)$\;
%Transform $\Gamma_1$ into a formula~\footnote{$X$ is a set of formulas, in this paper set $X$ and $\bigwedge X$ are expressing the conjunction of elements in $X$.}:
% \[\Gamma_2=\bigwedge X \wedge \bigwedge_{p\in (V'\setminus \Gamma)\cup V^F} (p\supset \varphi_1 \vee \dots \vee p\supset \varphi_n)\]

\Return $\bigwedge_{\psi \in R(\Gamma_1)_{\CTL}} \psi$.
\end{algorithm}

The Tran process is to transform the \CTL\ formula into a set of $\CTLsnf$ clauses by using the rules  Trans(1) to Trans(12).
The transformation of an arbitrary CTL formula into the set $T_{\varphi}$ is a sequence $T_0, T_1,\dots, T_n=T_{\varphi}$ of formulae with $T_0=\{\ALL \GLOBAL(\start \supset p), \ALL \GLOBAL(p \supset \simp(\nnf(\varphi)))\}$ such that for every $i$ ($0 \leq i< n$), $T_{i+1} = (T_i \setminus \{\psi\}) \cup R_i$~\cite{zhang2009refined}, where $\psi$ is a formula in $T_i$ not in $\CTLsnf$ clause and $R_i$ is the result set of applying a matching transformation rule to $\psi$. Note that throughout the transformation formulae are kept in negation normal form (NNF).
\begin{proposition}\label{pro:TranE}
 Let $\varphi$ be a \CTL\ formula, then $\varphi \equiv_{\tuple{V', I}} T_{\varphi}$.
\end{proposition}
\begin{proof} (sketch)
This can be proved from $T_i$ to $T_{i+1}$ $(0\leq i < n)$ by using one transformation rule on $T_i$.

%We will prove this proposition from the following several aspects:
%
%(1) $\varphi \equiv_{\tuple{\{p\}, {\O}}} T_0$.
%
% $(\Rto)$ $\forall (\Hm_1,s_1) \in \Mod(\varphi)$, \ie $(\Hm_1,s_1) \models \varphi$. We can construct an \Ind-model structure $\Hm_2$ is identical to $\Hm_1$ except $L_2(s_2) = L_1(s_1) \cup \{p\}$. It is apparent that $(\Hm_2,s_2) \models T_0$ and $(\Hm_1, s_1) \lrto_{\tuple{\{p\}, {\O}}} (\Hm_2, s_2)$.
%
% $(\Lto)$ $\forall (\Hm_1,s_1) \in \Mod(T_0)$, it is apparent that $(\Hm_1,s_1) \models \varphi$ by the sematic of $\start$.
%
%By $\psi \rto_t R_i$ we mean using transformation rules $t$ on formula $\psi$ (the formulae $\psi$ as the
%premises of rule $t$) and obtaining the set  $R_i$ of transformation results. Let $X$ be a set of formulas
%we will show $T_i \equiv_{\tuple{V',I}} T_{i+1}$ by using the transformation rule $t$. Where $T_i= X \cup \{\psi\}$, $T_{i+1}=X \cup R_i$, $V'$ is the set of atoms introduced by $t$ and $I$ is the set of indexes introduced by $t$. (We will prove this result in $t\in \{$Trans(1), Trans(4), Trans(6)$\}$, other cases can be proved similarly.)
%
%(2) For $t$=Trans(1):\\
% $(\Rto)$ $\forall (\Hm_1,s_1) \in \Mod(T_i)$ \ie $(\Hm_1, s_1) \models X \wedge \ALL\GLOBAL(q \supset \EXIST \NEXT \varphi)$\\
% $\Rto$ $(\Hm_1,s_1)\models X$ and for every $\pi$ starting from $s_1$ and every state $s_1^j \in \pi$, $(\Hm,s_1^j) \models \neg q$ or there exists a path $\pi'$ starting from $s_1^j$ such that there exists a state $s_1^{j+1}$ such that $(s_1^j,s_1^{j+1})\in R_1$ and $(\Hm,s_1^{j+1})\models \varphi$\\
% We can construct an \Ind-model structure $\Hm_2$ is identical to $\Hm_1$ except  $[ind]_2= \bigcup_{s\in S} R_s \cup R_y$, where $R_{s_1^{j}}=\{(s_1^{j},s_1^{j+1}), (s_1^{j+1}, s_1^{j+2}),\dots\}$ and $R_y=\{(s_x,s_y)| \forall s_x \in S$ if $\forall (s_1',s_2')\in \bigcup_{s\in S} R_s, s_1'\neq s_x$ then find a unique $s_y\in S$ such that $(s_x,s_y)\in R\}$. It is apparent that $(\Hm_1, s_1) \lrto_{\tuple{{\O}, \{ind\}}} (\Hm_2, s_2)$ (let $s_2=s_1$).\\
% $\Rto$ for every path starting from $s_1$ and every state $s_1^j$ in this path, $(\Hm_2, s_1^j) \models \neg q$ or $(\Hm_2, s_1^j)\models \EXIST \NEXT \varphi_{\tuple{ind}}$ \hfill (by the semantic of $\EXIST \NEXT$)\\
% $\Rto$ $(\Hm_2, s_1) \models \ALL \GLOBAL(q \supset \EXIST_{\tuple{ind}} \NEXT \varphi )$\\
% $\Rto$ $(\Hm_2, s_1) \models X \wedge \ALL \GLOBAL(q \supset \EXIST_{\tuple{ind}} \NEXT \varphi )$
%
% $(\Lto)$ $\forall (\Hm_1,s_1) \in \Mod(T_{i+1})$ \ie $(\Hm_1,s_1) \models X \wedge \ALL \GLOBAL(q \supset \EXIST_{\tuple{ind}} \NEXT \varphi )$\\
% $\Rto$ $(\Hm_1,s_1) \models X$ and $(\Hm_1,s_1) \models \ALL \GLOBAL(q \supset \EXIST_{\tuple{ind}} \NEXT \varphi)$\\
% $\Rto$ for every path starting from $s_1$ and every state $s_1^j$ in this path, $(\Hm_1, s_1^j) \models \neg q$ or there exits a state $s'$ such that $(s_1^j, s')\in [ind]_1$ and $(\Hm_1, s') \models \varphi$ \hfill (by the semantic of $\EXIST_{\tuple{ind}} \NEXT$)\\
% $\Rto$ for every path starting from $s_1$ and every state $s_1^j$ in this path, $(\Hm_1, s_1^j) \models \neg q$ or $(\Hm_1, s_1^j) \models \EXIST \NEXT \varphi$ \hfill (by the semantic of $\EXIST \NEXT$)\\
% $\Rto$ $(\Hm_1,s_1) \models \ALL\GLOBAL(q \supset \EXIST \NEXT \varphi)$\\
% $\Rto$ $(\Hm_1, s_1) \models X \wedge \ALL\GLOBAL(q \supset \EXIST \NEXT \varphi)$\\
% It is apparent that $(\Hm_1, s_1) \lrto_{\tuple{{\O}, \{ind\}}} (\Hm_1, s_1)$.
%
%(3) For $t$=Trans(4):\\
% $(\Rto)$ $\forall (\Hm_1,s_1) \in \Mod(T_i)$, \ie $(\Hm_1,s_1) \models X \wedge \ALL\GLOBAL (q \supset \varphi_1 \vee \varphi_2)$ \\
% $\Rto$ $(\Hm_1,s_1) \models X$ and $\forall s_1'\in S, (\Hm_1,s_1') \models q \supset \varphi_1 \vee \varphi_2$\\
% $\Rto$ $(\Hm_1,s_1') \models \neg q$ or $(\Hm_1,s_1') \models \varphi_1 \vee \varphi_2$\\
% The we can construct an \Ind-model structure $\Hm_2$ as follows. $\Hm_2$ is the same with $\Hm_1$ when $(\Hm_1,s_1') \models \neg q$. When $(\Hm_1,s_1') \models q$, $\Hm_2$ is identical to $\Hm_1$ except if $(\Hm_1,s_1') \models \varphi_1$ then $L_2(s_1')= L_1(s_1')$ else $L_2(s_1') = L_1(s_1') \cup \{p\}$. It is apparent that $(\Hm_2,s_1') \models (q\supset \varphi_1 \vee p) \wedge (p \supset \varphi_2)$, then $(\Hm_2,s_1) \models T_{i+1}$ and $(\Hm_1, s_1) \lrto_{\tuple{\{p\}, {\O}}} (\Hm_2, s_2)$.
%
% $(\Lto)$ $\forall (\Hm_1, s_1) \in \Mod(T_{i+1})$, \ie $(\Hm_1,s_1) \models X \wedge \ALL\GLOBAL (q\supset \varphi_1 \vee p) \wedge \ALL\GLOBAL(p \supset \varphi_2)$. It is apparent that $(\Hm_1, s_1) \models T_i$.
%
%
%(4) For $t$=Trans(6):\\
%We prove for $\EXIST_{\tuple{ind}} \NEXT$, while for the $\ALL \NEXT$ can be proved similarly.
%
% $(\Rto)$ $\forall (\Hm_1,s_1) \in \Mod(T_i)$, \ie $(\Hm_1,s_1) \models X \wedge \ALL\GLOBAL(q \supset \EXIST_{\tuple{ind}}\NEXT \varphi)$\\
% $\Rto$ $(\Hm_1,s_1) \models X$ and $\forall s_1'\in S, (\Hm_1,s_1') \models q \supset \EXIST_{\tuple{ind}} \NEXT \varphi$\\
% $\Rto$ $(\Hm_1,s_1') \models \neg q$ or there exists a state $s'$ such that $(s_1', s') \in [ind]$ and $(\Hm_1,s') \models \varphi$ \\
% We can construct an \Ind-model structure $\Hm_2$ as follows. $\Hm_2$ is the same with $\Hm_1$ when $(\Hm_1,s_1') \models \neg q$. When $(\Hm_1,s_1') \models q$, $\Hm_2$ is identical to $\Hm_1$ except for $s'$ there is $L_2(s') = L_1(s') \cup \{p\}$. It is apparent that $(\Hm_2,s_1) \models \ALL\GLOBAL(q\supset \EXIST_{\tuple{ind}} \NEXT p) \wedge \ALL\GLOBAL(p \supset \varphi)$, $(\Hm_2,s_2) \models T_{i+1}$ and $(\Hm_1, s_1) \lrto_{\tuple{\{p\}, {\O}}} (\Hm_2, s_2)$ ($s_2=s_1$).
%
%  $(\Lto)$ $\forall (\Hm_1, s_1) \in \Mod(T_{i+1})$, \ie $(\Hm_1,s_1) \models X \wedge \ALL\GLOBAL(q\supset \EXIST_{\tuple{ind}} \NEXT p) \wedge \ALL\GLOBAL(p \supset \varphi)$. It is apparent that $(\Hm_1, s_1) \models T_i$.

\end{proof}

This means that $\varphi$ has the same models with $T_{\varphi}$ excepting that the atoms in $V'$ and the relations $[i]$ with $i\in I$.

\begin{algorithm}[!h]
\caption{$Tran(\varphi)$}% ??????
\label{alg:compute:transformation}
%\LinesNumbered %?????????
\KwIn{A CTL formula $\varphi$}% ????????
\KwOut{A set $T$ of $\CTLsnf$ clauses and a set $V'$ of atoms}% ????
$T={\O}$ // the initial set of $\CTLsnf$ clauses of $\varphi$ \;
$OldT=\{\start \supset z, z \supset \varphi\}$\;
$V'=\{z\}$\;
\While {$OldT\neq T$} {
    $OldT=T$\;
    $R={\O}$\;
    $X={\O}$\;
    \If {Chose a formula $\psi\in OldT$ that dose not a $\CTLsnf$ clause}{
    Using a match rule $Rl$ to transform $\psi$ into a set $R$ of $\CTLsnf$ clauses\;
    $X$ is the set of atoms introduced by using $Rl$\;
    $V' =V' \cup X$\;
    $T=OldT\setminus \{\psi\} \cup R$\;
    }
}

\end{algorithm}

The Res process is to compute all the possible resolutions of $T_{\varphi}$ on $V'$.
A \emph{derivation} on a set $V\cup V'$ of atoms and $T_{\varphi}$ is a sequence $T_0, T_1, T_2$, $\dots$, $T_n=T_{\varphi}^{r,V \cup V'}$ of sets of $\CTLsnf$ clauses such that $T_0 = T_{\varphi}$ and $T_{i+1} = T_i \cup R_i$ where $R_i$ is a set of clauses obtained as the conclusion of the application of a resolution rule to premises in $T_i$.
Note that all the $T_i$ ($0 \leq i \leq n$) are set of $\CTLsnf$ clauses.
Besides, if there is a $T_i$ containing $\start\supset \perp$ or $\top\supset \perp$, then we have $\CTLforget(\varphi, V)=\perp$.
Given two clauses $C$ and $C'$, we call $C$ and $C'$ are resolvable, the result denote as $res(C,C')$, if there is a resolution rule using $C$ and $C'$ as the premises on some given atom.
Then the pseudocode of algorithm Res is as Algorithm~\ref{alg:compute:Res}.

\begin{proposition}\label{pro:ResE}
 Let $\varphi$ be a \CTL\ formula, then $T_{\varphi} \equiv_{\tuple{V \cup V', {\O}}} T_{\varphi}^{r,V \cup V'}$.
\end{proposition}
\begin{proof}(sketch)
This can be proved from $T_i$ to $T_{i+1}$ $(0\leq i < n)$ by using one resolution rule on $T_i$.
%
%By $\psi \rto_r R_i$ we mean using resolution rules $r$ on set $\psi$ (the formulae in $\psi$ as the premises of rule $r$) and obtaining the set $R_i$ of resolution results.
%we will show $T_i \equiv_{\tuple{V,I}} T_{i+1}$ by using the resolution rule $r$. Where $T_i= X \cup \psi$, $T_{i+1}=X \cup R_i$, $X$ be a set of $\CTLsnf$ clauses, $p$ be the proposition corresponding with literal $l$ used to do resolution in $r$.
%
%(1) If $\psi \rto_r R_i$ by an application of $r\in \{\textbf{(SRES1)}, \dots, \textbf{(SRES8)}, \textbf{RW1}, \textbf{RW2}\}$, then $T_i \equiv_{\tuple{\{p\}, {\O}}} T_{i+1}$.
%
%
%On one hand, it is apparent that $\psi \models R_i$ and then $T_i \models T_{i+1}$. On the other hand, $T_i\subseteq T_{i+1}$ and then $T_{i+1} \models T_i$.
%
%(2) If $\psi \rto_r R_i$ by an application of $r=$\textbf{(ERES1)},
%then $T_i \equiv_{\tuple{\{l, w_{\neg l}^{\ALL}\}, {\O}}} T_{i+1}$.
%
%It has been proved that $\psi \models R_i$ in~\cite{bolotov2000clausal}, then there is $T_{i+1}=T_i \cup \Lambda_{\neg l}^{\ALL}$ and  then $\forall (\Hm_1,s_1) \in \Mod(T_i= X \cup \psi)$ there is a $(\Hm_2, s_2)\in \Mod(T_{i+1}=T_i \cup \Lambda_{\neg l}^{\ALL})$ s.t. $(\Hm_1, s_1) \lrto_{\tuple{\{p, w_{\neg l}^{\ALL}\}, {\O}}} (\Hm_2, s_2)$ and vice versa by Proposition~\ref{pro:TranE}.
%
%For rule \textbf{(ERES2)} we have the same result.

\end{proof}
Proposition~\ref{pro:TranE} and Proposition~\ref{pro:ResE} mean that $\varphi \equiv_{\tuple{V \cup V', I}} T_{\varphi}^{r,V \cup V'}$, this resolve the problem (1).

\begin{algorithm}[!h]
\caption{$Res(T, V')$}% ??????
\label{alg:compute:Res}
%\LinesNumbered %?????????
\KwIn{A set $T$ of $\CTLsnf$ clauses and a set $V'$ of atoms}% ????????
\KwOut{A set $Res$ of $\CTLsnf$ clauses}% ????

$S=\{C | C\in T$ and $\Var(C) \cap V= {\O}\}$\;
$\Pi=T\setminus S$ \;
\For {($p\in V\cup V')$} {
    $\Pi'=\{C \in \Pi| p\in \Var(C)\}$ \;
    $\Sigma = \Pi \setminus \Pi'$\;
    \For {($C\in \Pi'$ s.t. $p$ appearing in  $C$ positively)} {
        \For {($C'\in\Pi'$ s.t. $p$ appearing in  $C'$ negatively and $C$, $C'$ are resolvable)}{
            $\Sigma = \Sigma \cup \{res(C,C')\}$\;
            $\Pi' = \Pi' \cup \{C''=res(C,C') | p\in \Var(C'')\}$\;
        }
    }
    $\Pi= \Sigma$\;
}

$Res=\Pi \cup S$\;

\end{algorithm}

For resolving problem (2), we should pay attention to the fact that by the transformation and resolution rules, we have the following several important properties:
\begin{itemize}
  \item \textbf{(GNA)} for all atom $p$ in $\Var(\varphi)$, $p$ do not positively appear in the left hand of the $\CTLsnf$ clause;
  %\item \textbf{(CNI)} for each global clause, there must be an atom $p\in V'$ appearing in the right hand negatively;
  \item \textbf{(PI)} for each atom $p\in V'$, if $p$ appearing in the left hand of a $\CTLsnf$ clause, then $p$ appear positively.
\end{itemize}



An \emph{instantiate formula} $\psi$ of set $V''$ of atoms is a formula such that $\Var(\psi) \cap V'' ={\O}$. A key point to compute forgetting is eliminate those irrelevant atoms, for this purpose, we define the follow substitution to find out those atoms that do irrelevant.
\begin{definition}\label{def:subst}
[substitution] Let $V''=V'$ and $\Gamma=T_{\varphi}^{r,V \cup V'}$, then the process of substitution is as follows:
\begin{enumerate}[(i)]
  \item for each global clause $C= \top \supset D \vee \neg p \in \Gamma$, if there is one and on one atom $p \in V''\cap \Var(C)$  and $\Var(D) \cap V = {\O}$ then let $C = p \supset D$ and $V'':=V''\setminus \{p\}$;
  \item find out all the possible instantiate formulae $\varphi_1, ..., \varphi_m$ of $V \cup V''$ in the $p\supset \varphi_i \in \Gamma$ ($1\leq i\leq m$);
  \item if there is $p\supset \varphi_i$ for some $i\in \{1,\dots, m\}$, then let $V'':=V''\setminus \{p\}$, which means $p$ is a instantiate formula;
  \item for $\bigwedge_{j=1}^m p_j \supset \varphi_i \in \Gamma$ ($i\in \{1,\dots, m\}$), if there is $\alpha \supset p_1,\dots, \alpha \supset p_m \in \Gamma$ then let $\Gamma_1 := \Gamma \cup \{\alpha \supset \varphi\}$. if $\Gamma_1\neq \Gamma$ then let $\Gamma:=\Gamma_1$ go to step (i), else return $V \cup V''$.
\end{enumerate}
Where $p, p_i$ ($1 \leq i\leq m$) are atoms and $\alpha$ is a conjunction of literals or $\start$.
\end{definition}

We denote this process as $\Sub(\Gamma, V')$, which can be described as the following Algorithm~\ref{alg:subn}.

\begin{algorithm}[!h]
\caption{Computing $\Sub(\Gamma, V')$}% ??????
\label{alg:subn}
%\LinesNumbered %?????????
\KwIn{A set $\Gamma$ of $\CTLsnf$ clauses $\varphi$ and $V,V'\subseteq \Ha$}% ????????
\KwOut{A set of atoms}% ????
Let $V'':=V'$\;
Let $V_1= \emptyset$\;
Let $\Gamma_1 :=\emptyset$\;
Let $\Gamma_2 := \Gamma$\;
\While {($\Gamma_1\neq \Gamma_2$ or $V_1 \neq V''$)} {
    $\Gamma_1:=\Gamma_2$\;
    $V_1 := V''$\;
    \For {($C \in \Gamma_2$)} {
        \If {($C$ is a global clause)} {
            Let $C:=D \vee \neg p$\;
            \If{($p\in V''\cap \Var(C)$ and $\Var(D) \cap V==\emptyset$)} {
                $C:= p\supset D$\;
                $V'' := V'' \setminus \{p\}$\;
            }
        }
    }

    \For {($C \in \Gamma_2$)} {
        \If {($C== p\supset \varphi$ and $p\in V''$ and $\Var(\varphi) \cap V\cup V'' == \emptyset$)} {
            $V'' := V'' \setminus \{p\}$\;
        }
    }

    \For {($C \in \Gamma_2$)} {
        \If {($C==\bigwedge_{j=1}^m p_j \supset \varphi$ and $\Var(\varphi) \cap V\cup V'' == \emptyset$)} {
            \If {(there is $\alpha \supset p_1, \dots, \alpha \supset p_m \in \Gamma_2$)} {
                $\Gamma_2 := \Gamma_2 \cup \{\alpha \supset \varphi\}$\;
            }
        }
    }
}



\Return $V \cup V''$.
\end{algorithm}

\begin{example}\label{exa:until:sub}
Let $\varphi=\ALL((p\wedge q) \UNTIL (f\vee m)) \wedge r$ and $V=\{p\}$. Then we can compute $\Sub(T_{\varphi}^{r,V \cup V'}, V)$ as follows:

At first, we transform $\varphi$ into a set of $\CTLsnf$ with $V'=\{x,y,z\}$, which is listed as:
\begin{align*}
& 1. \start\supset z && 2. \top \supset \neg z \vee r && 3.\top \supset \neg x\vee f \vee m\\
& 4. \top \supset \neg z \vee x \vee y && 5.\top \supset \neg y \vee p && 6.\top \supset \neg y \vee q\\
& 7. z \supset \ALL \FUTURE x && 8. y \supset \ALL \NEXT(x\vee y).
\end{align*}

In the second, we compute all the possible resolutions on $V\cup V'$ and is listed as:
\begin{align*}
&(1) \start \supset r && (2) \start \supset x \vee y &&(3) \top \supset \neg z \vee y \vee f \vee m \\
& (4) y \supset \ALL\NEXT(f\vee m\vee y) &&(5) \top \neg z \vee x \vee p && (6) \top \neg z \vee x \vee q\\
&(7) y \supset \ALL\NEXT(x\vee p) && (8) y \supset \ALL\NEXT(x\vee q) &&(9) \start \supset f\vee m \vee y \\
& (10) \start \supset x \vee p &&(11) \start \supset x \vee q && (12) \top \supset p \vee \neg z \vee f \vee m \\
&(13) \top \supset q \vee \neg z \vee f \vee m && (14) y \supset \ALL\NEXT(p \vee f\vee m) &&(15) y \supset \ALL\NEXT(q \vee f\vee m) \\
& (16) \start \supset f\vee m \vee p &&(17) \start \supset f\vee m \vee q.
\end{align*}

By the process of substitution we obtain that $y$ is instantiated by $q \wedge \ALL\NEXT(p \vee f\vee m)$, $x$ is instantiated by $f\vee m$ and $z$ is instantiated by $r$. That is $\Sub(T_{\varphi}^{r,V \cup V'}, V') = V$, which means all the introduced atoms are instantiated.
\end{example}

By $\Sub$ operator, we guarantee those atoms in $V\cup V''$ are really irrelevant atoms.

Let $P$ be a conjunction of literals, $l$, $l_1$ be literals, in which $\Var(C_1)\cap V \cup V' = {\O}$, and $C_i$ ($i\in \{2,3,4\}$) be classical clauses.
 %Besides, by $l \supset \neg C_1 \vee C_2$ we mean the set $\{l \supset \neg C_{1,1} \vee C_2, \dots, l \supset \neg C_{1,x} \vee C_2$, where $C_{1,i}$ is a literal appearing in $C_1$.
As we can see that those exist resolution rules cannot deduct all the possible result, et so we add following new rules:
\begin{align*}
& \textbf{(EF1)} \{P\supset \ALL\FUTURE l, P\supset \EXIST_{\tuple{ind}}\NEXT (l_1 \vee C_4),
% P\supset \EXIST_{\tuple{ind}}\NEXT (\neg l \vee C_2 \vee C_4),
  l \supset \neg l_1 \vee C_2, l \supset C_3\vee C_2\} \\
&  \qquad \rto\{P \supset ((\neg C_3 \wedge \neg C_2) \supset  (\EXIST_{\tuple{ind}}\NEXT(C_3 \wedge \neg (C_2 \vee C_4) \supset
\ALL\NEXT \ALL\FUTURE(C_3 \vee C_2))))\},\\
& \textbf{(EF2)} \{P\supset \ALL\FUTURE l, P\supset \ALL \NEXT (l_1 \vee C_4),
 %P\supset \ALL\NEXT (\neg l \vee C_2 \vee C_4),
 l \supset \neg l_1 \vee C_2, l \supset C_3\vee C_2\}  \\
& \qquad \rto \{ P \supset ((\neg C_3 \wedge \neg C_2) \supset (\ALL\NEXT(C_3 \wedge  \neg (C_2 \vee C_4) \supset
 \ALL\NEXT \ALL\FUTURE(C_3 \vee C_2))))\}\\
& \textbf{(EF3)} \{P\supset \EXIST_{\tuple{ind}}\FUTURE l, P\supset \EXIST_{\tuple{ind}}\NEXT (l_1 \vee C_4),
% P\supset \EXIST_{\tuple{ind}}\NEXT (\neg l \vee C_2 \vee C_4),
  l \supset \neg l_1 \vee C_2, l \supset C_3\vee C_2\}  \\
& \qquad \rto \{P \supset ((\neg C_3 \wedge \neg C_2) \supset (\EXIST_{\tuple{ind}}\NEXT(C_3 \wedge  \neg (C_2 \vee C_4) \supset
 \ALL\NEXT \ALL\FUTURE(C_3 \vee C_2))))\},\\
& \textbf{(EF4)} \{P\supset \EXIST_{\tuple{ind}}\FUTURE l, P\supset \ALL\NEXT (l_1 \vee C_4),
 %P\supset \ALL\NEXT (\neg l \vee C_2 \vee C_4),
 l \supset \neg l_1 \vee C_2, l \supset C_3\vee C_2\}  \\
& \qquad \rto \{P \supset ((\neg C_3 \wedge \neg C_2) \supset (\EXIST_{\tuple{ind}}\NEXT(C_3 \wedge  \neg (C_2 \vee C_4) \supset
\ALL\NEXT \ALL\FUTURE(C_3 \vee C_2))))\}
\end{align*}



By $\EXIST\FUTURE(\Sub(T_{\varphi}^{r,V \cup V'}, V'))$ we mean using \textbf{(EF1)} to \textbf{(EF4)} on $T_{\varphi}^{r,V \cup V'}$ and replace $P\supset \EXIST_{\tuple{ind}}\NEXT (\neg l \vee C_2 \vee C_4)$ with $P\supset \EXIST_{\tuple{ind}}\NEXT (\neg l \vee C_2 \vee C_4) \vee \bigwedge W$  when $l$, $C_2$, $C_3$  and $C_4$ are instantiate formulae of  $\Sub(T_{\varphi}^{r,V \cup V'}, V')$ and $\Var(l_1) \in V\cup V'$.
%This is similar with the resolution process except by those rules it will not product new resolution due to the new formulae obtained from those rules are instantiate formulae of  $\Sub(T_{\varphi}^{r,V \cup V'}, V')$.
This process can be described as Algorithm~\ref{alg:EF}.
\begin{algorithm}[!h]
\caption{Computing $\EXIST\FUTURE(\Gamma, V)$}% ??????
\label{alg:EF}
%\LinesNumbered %?????????
\KwIn{A set $\Gamma$ of $\CTLsnf$ clauses, a set of $\ALL$-step clauses and a set of $\EXIST$-step clauses}% ????????
\KwOut{A set of formulae}% ????

 $C_1 :=P \supset ((\neg C_3 \wedge \neg C_2) \supset  (\EXIST_{\tuple{ind}}\NEXT(C_3 \wedge \neg (C_2 \vee C_4) \supset
\ALL\NEXT \ALL\FUTURE(C_3 \vee C_2))))$\;
$C_1' := P \supset ((\neg C_3 \wedge \neg C_2) \supset  (\ALL\NEXT(C_3 \wedge \neg (C_2 \vee C_4) \supset
\ALL\NEXT \ALL\FUTURE(C_3 \vee C_2))))$\;
\For {($C \in A$)} {
    Let $C == P \supset \ALL \FUTURE l$\;
    \If {$(P\supset \EXIST_{\tuple{ind}}\NEXT (l_1 \vee C_4),  l \supset \neg l_1 \vee C_2, l \supset C_3\vee C_2\in \Gamma$ and $l,C_2, C_3, C_4$ are initial formulae)} {
        Replacing $P\supset \EXIST_{\tuple{ind}}\NEXT (\neg l \vee C_2 \vee C_4)$ with $P\supset \EXIST_{\tuple{ind}}\NEXT (\neg l \vee C_2 \vee C_4) \vee C_1$\;
    }
    \If {$( P\supset \ALL \NEXT (l_1 \vee C_4), l \supset \neg l_1 \vee C_2, l \supset C_3\vee C_2\in \Gamma$ and $l,C_2, C_3, C_4$ are initial formulae)} {
        Replacing $P\supset \ALL\NEXT (\neg l \vee C_2 \vee C_4)$ with $P\supset \ALL\NEXT (\neg l \vee C_2 \vee C_4) \vee C_1'$\;
    }
}


\For {($C \in E$)} {
    Let $C == P \supset \EXIST_{\tuple{ind}} \FUTURE l$\;
    \If {$(P\supset \EXIST_{\tuple{ind}}\NEXT (l_1 \vee C_4),  l \supset \neg l_1 \vee C_2, l \supset C_3\vee C_2\in \Gamma \hbox{ or } P\supset \ALL \NEXT (l_1 \vee C_4), l \supset \neg l_1 \vee C_2, l \supset C_3\vee C_2\in \Gamma$ and $l,C_2, C_3, C_4$ are initial formulae)} {
        Replacing $P\supset \EXIST_{\tuple{ind}}\NEXT (\neg l \vee C_2 \vee C_4)$ with $P\supset \EXIST_{\tuple{ind}}\NEXT (\neg l \vee C_2 \vee C_4) \vee C_1$\;
    }
}

%Using distribution law two change $\Gamma$ into a sequence $\Gamma_1, \dots, \Gamma_m$ of sets of $\CTLsnf$ clauses\;
\Return $\Gamma$.
\end{algorithm}

\begin{proposition} \label{pro:EF}
Let $\Gamma=T_{\varphi}^{r,V \cup V'}$, we have $\Gamma \equiv_{\tuple{V', {\O}}}\EXIST\FUTURE(\Sub(\Gamma, V'))$.
\end{proposition}
\begin{proof}
It is obvious from the  \textbf{(EF1)} to \textbf{(EF4)}.

We prove the (EF1), for other rules can be proved similarly.
Let $T_{i+1}=T_i \cup \{\varphi\}$, where $\{\varphi\}$ is obtained from $T_i$ by using rule (EF1) on $T_i$, \ie $\varphi =P \supset ((\neg C_3 \wedge \neg C_2) \supset  (\EXIST_{\tuple{ind}}\NEXT(C_3 \wedge \neg (C_2 \vee C_4) \supset \ALL\NEXT \ALL\FUTURE(C_3 \vee C_2))))$.
It is apparent that $T_{i+1} \models T_i$ and $T_i \models P\supset \EXIST_{\tuple{ind}}\NEXT (\neg l \vee C_2 \vee C_4)$.
We will show that $\forall (\Hm, s_0) \in \Mod(T_i)$ there is an initial Ind-structure $(\Hm',s_0')$ such that $(\Hm',s_0') \models T_{i+1}$ and $(\Hm',s_0') \lrto_{\tuple{V', {\O}}} (\Hm, s_0)$

$\forall (\Hm, s) \models T_i$ we suppose $(\Hm, s) \models P \wedge \neg C_3 \wedge \neg C_2$ and $(\Hm, s_1)\models C_3 \wedge \neg C_2 \wedge \neg C_4$ with $(s, s_1) \in [ind]$ (due to other case can be proved easily).
Then we have $(\Hm, s) \nvDash l$ (by $(\Hm, s) \models l \supset C_3 \vee C_2$) and $(\Hm,s_1) \models l_1$ (by $(\Hm, s) \models P\supset \EXIST_{\tuple{ind}}\NEXT (l_1 \vee C_4)$).
If $(\Hm,s_1) \nvDash \ALL\NEXT \ALL\FUTURE(C_3 \vee C_2)$ then we have $(\Hm, s_1) \models l$ due to $(\Hm, s) \models \ALL\GLOBAL(l\supset C_3 \vee C_2)$ and $(\Hm, s)\models \ALL\FUTURE l$.
And then $(\Hm, s_1) \models \neg l_1$ by $(\Hm,s) \models \ALL \GLOBAL(l\supset \neg l_1 \vee C_2)$.
It is contract with our supposing.
Then $(\Hm,s_1) \models \ALL\NEXT \ALL\FUTURE(C_3 \vee C_2)$.

%By Proposition~\ref{pro:TranE} we have $\forall (\Hm, s) \in \Mod(\varphi)$ there is an initial Ind-structure $(\Hm',s')$ such that $(\Hm', s')\models T_{\varphi}$ and $(\Hm,s) \lrto_{\tuple{V_F, \emptyset}} (\Hm, s)$.

\end{proof}



For eliminate those irrelevant atoms, we can do the following elimination operator.
\begin{definition}\label{def:Elm}
\textbf{(Elimination)}
Let $T$ be a set of formulae, $C \in T$ and $V$ a set of atoms, then the elimination operator, denoted as $\Elm$, is defined as:
$$ \Elm(C, V)=\left\{
\begin{aligned}
\top, && if\ \Var(C) \cap V \neq {\O} \\
C, && else.
\end{aligned}
\right.
$$
\end{definition}
For convenience, we let $\Elm(T, V) = \{\Elm(r, V) | r \in T\}$.




\begin{proposition}\label{pro:elm}
Let $V''=V \cup V'$, $\Gamma=\Sub(T_{\varphi}^{r, V''}, V')$ and $\Gamma_1=\Elm (\EXIST\FUTURE(\Gamma), \Gamma)$, then  $\Gamma_1\equiv_{\tuple{V\cup V', {\O}}} T_{\varphi}^{r, V''}$ and $\Gamma_1 \equiv_{\tuple{V \cup V', I}} \varphi$.
\end{proposition}
\begin{proof}
Note the fact that for each clause $C = T \supset H$ in $\EXIST\FUTURE(\Gamma)$, if $\Gamma \cap \Var(C) \neq \emptyset$ then there must be an atom $p\in \Gamma \cap \Var(H)$. It is apparent that $\EXIST\FUTURE(\Gamma) \models \Gamma_1$, we will show $\forall (\Hm, s_0) \in \Mod(\Gamma_1)$ there is a $(\Hm', s_0)$ such that $(\Hm', s_0) \models \EXIST\FUTURE(\Gamma)$ and $(\Hm, s_0) \lrto_{\tuple{\Gamma, \emptyset}} (\Hm', s_0)$.
Let $C = T \supset H$ in $\EXIST\FUTURE(\Gamma)$ with $\Gamma \cap \Var(C) \neq \emptyset$,
$\forall (\Hm, s_0) \in \Mod(\Gamma_1)$ we construct $(\Hm', s_0)$ as $(\Hm, s_0)$ except
%We will proof this proposition from the following two points.
 for each $s\in S$, if $(\Hm, s) \nvDash T$ then $L'(s) = L(s)$, else:
\begin{enumerate}[(i)]
  \item if $(\Hm,s) \models H$, then $L'(s) = L(s)$;
  \item else if $(\Hm, s) \models T$ with $p \in \Var(H)\cap V$, then if $p$ appearing in $H$ negatively, then if $C$ is a global (or an initial) clause then let $L'(s) = L(s) \setminus \{p\}$ else let $L'(s_1) = L(s_1) \setminus \{p\}$ for (each (if $C$ is an $\ALL$-step or $\ALL$-sometime clause)) $(s,s_1) \in R$, else if $C$ is a global (or an initial) clause then let $L'(s) = L(s) \cup \{p\}$ else let $L'(s_1) = L(s_1) \cup \{p\}$ for (each (if $C$ is a $\ALL$-step or $\ALL$-sometime clause)) $(s,s_1) \in R$.
  \item for other clause $C=Q\supset H$ with $p\in \Var(H)\cap \Gamma$, we can do it as (ii).
\end{enumerate}

It is apparent that $(\Hm, s_0) \lrto_{\tuple{\Gamma, \emptyset}} (\Hm', s_0)$, we will show that $(\Hm', s_0) \models \EXIST\FUTURE(\Gamma)$ from the following two points:
\begin{enumerate}[(1)]
  \item For (ii) talked-above, we show it from the form of $\CTLsnf$ clauses. Supposing $C_1$ and $C_2$ are instantiate formula of $\Gamma$:
  \begin{enumerate}[(a)]
    \item If $C$ is a global clause, i.e. $C=\top \supset p \vee C_1$ with $C_1$ is a disjunction of literals (we suppose $p$ appearing in $C$ positively). If there is a $C'=\top \supset \neg p \vee C_2 \in \EXIST\FUTURE(\Gamma)$, then there is $\top \supset C_1 \vee C_2 \in \EXIST\FUTURE(\Gamma)$ by the resolution ($(\Hm,s) \models C_2$ due to we have suppose $(\Hm,s) \nvDash C$). It is apparent that $(\Hm', s_0) \models C \wedge C'$.
    \item If $C = T \supset \EXIST_{\tuple{ind}}\NEXT (p \vee C_1)$.
    %We talk about the case that $(\Hm,s)\models T$ and $(\Hm,s)\nvDash \EXIST_{\tuple{ind}}\NEXT (p \vee C_1)$
        If there is a $C'=T' \supset \EXIST_{\tuple{ind}}\NEXT( \neg p \vee C_2) \in \EXIST\FUTURE(\Gamma)$, then there is $T\wedge T' \supset \EXIST_{\tuple{ind}}\NEXT(C_1 \vee C_2) \in \EXIST\FUTURE(\Gamma)$  by the resolution ($(\Hm,s) \models \EXIST_{\tuple{ind}}\NEXT C_2$ due to we have suppose $(\Hm,s) \nvDash C$). It is apparent that $(\Hm', s_0) \models C \wedge C'$.
    \item Other cases can be proved similarly.
  \end{enumerate}

  \item (iii) can be proved as (ii) due to the fact we point at the beginning.
\end{enumerate}
Therefore, we have $\Gamma_1\equiv_{\tuple{V\cup V', {\O}}} T_{\varphi}^{r, V''}$  by Proposition~\ref{pro:VI:div} and Proposition~\ref{pro:EF}.

And then $\Gamma_1 \equiv_{\tuple{V \cup V', I}} \varphi$ follows.
\end{proof}


The $\NI(\Gamma)$ process is to change the set $\Gamma$ of $\CTLsnf$ into a set of formulas without the index by using the equations in Proposition~\ref{pro:In2NI}.

\begin{lemma}\label{lem:No:Ind}
\textbf{(NI-BRemain)}
Let $T$ be a set of $\CTLsnf$ clauses and $T'$ be the nonInd-$\CTLsnf$ of $T$.
If $T$ is satisfiable, then we have $T \equiv_{\tuple{{\O}, I}} \NI(T)$,
%Then $\forall (\Hm,s_0) \in \Mod(T)$ there is a $(\Hm',s_0') \in \Mod(T')$ such that $(\Hm,s_0) \lrto_{\tuple{{\O}, I}} (\Hm',s_0')$ and vice versa.
where $I$ is the set of indexes in $T$.
\end{lemma}
\begin{proof}
It is easy checking that from the definition of $\NI$.
\end{proof}



Similarly, let $T$ be a set of $\CTLsnf$ clauses, then we define the following operator:
\begin{align*}
&T_{\CTL} = \{C|C'\in T\ \mbox{and}\ C = D \ \mbox{if}\ C' \mbox{is the form}\ \ALL\GLOBAL(\start\supset D), \mbox{else}\ C= C'\}.
\end{align*}
Then $T \equiv T_{\CTL}$ by $\varphi \equiv \ALL \GLOBAL (\start \supset \varphi)$~\cite{bolotov2000clausal}.


The last step of our algorithm is to eliminate all the atoms in $V'$ which has been introduced in the process Tran. Let $V''=V \cup V'$, $\Gamma=\Sub(T_{\varphi}^{r, V''}, V')$ and $\Gamma_1=\Elm (\EXIST\FUTURE(\Gamma))$, then $R(\NI(\Gamma_1))$ is obtained from $\NI(\Gamma_1)$ by doing the following two steps for each $p\in (V'\setminus \Gamma) \cup V^F$:
\begin{itemize}
  \item replacing each $p\supset \varphi_1\vee \dots \vee p \supset \varphi_n$ with $p \supset \bigvee_{i\in \{1,\dots, n\}} \varphi_i$;
  \item replacing $p\supset \varphi_{1}\wedge \dots \wedge p \supset \varphi_{m}$, $\varphi_j$ are instantiate formulae of  $\Gamma$ $(j \in \{1,\dots, m\})$, then let $\psi=\bigwedge_{i=1}^{j_n} \varphi_{j_i}$, where $p$ do not appear in $\varphi_{j_i}$, with $p \lrto \psi$.
  \item For other formula $C\in \Omega_1$, replacing every $p$ in $C$ with $\psi$.
\end{itemize}
Where $\NI(S)$ means do $\NI(e)$ for each $e\in S$ with $S$ is a set of sets of $\CTLsnf$ clause.
Apparently, this process is just a process of replacing each atom with an equivalent formula. Then we have:
\begin{proposition}
Let $\Gamma=T_{\varphi}^{r,V \cup V'}$, $\Gamma_1=\Sub(\Gamma, V')$ and $\Gamma_2 =\Elm (\EXIST\FUTURE(\Gamma_1), \Gamma_1)$, then $\Gamma_2  \equiv_{\tuple{V'\setminus \Gamma_1, {\O}}} R(\NI(\Gamma_2))$. and $\varphi \equiv_{\tuple{V\cup V',{I}}} R(\NI(\Gamma_2))_{CTL}$.
\end{proposition}
\begin{proof}
For each $p$ talked above is a name of the formula $\psi$, \ie $p \lrto \psi$.
Then $\Gamma_2  \equiv_{\tuple{(V'\setminus \Gamma_1) {\O}}} R(\Gamma_2)$, and then $\Gamma_2 \equiv_{\tuple{V\cup V', {\O}}} R(\Gamma_2)$  by (V) of Proposition~\ref{div}.

Therefore, $\varphi \equiv_{\tuple{V\cup V',{I}}} \NI(R(\Gamma_2))_{CTL}$ by Proposition~\ref{pro:elm} and the definitions of $\NI$ and $T_{\CTL}$.
\end{proof}




In the case that formula dose not include index, we use model structure $\Hm=(S,R,L, s_0)$ to interpret formula instead of \Ind-model structure. Therefore it is apparent that $\forall (\Hm,s_0) \in \Mod(\varphi)$ there is a $(\Hm',s_0') \in \Mod(\Gamma_1)$ such that $(\Hm,s_0) \lrto_{V \cup V'} (\Hm',s_0')$ and vice versa.


\begin{theorem}\label{thm:Res_based:V_CTLforget}
Let $V''=V \cup V'$, $\Gamma=\Sub(T_{\varphi}^{r, V''}, V')$ and $\Gamma_1= R(\NI(\Elm(\EXIST\FUTURE(\Gamma),\Gamma)))_{\CTL}$, then
\[
\CTLforget(\varphi, V' \cup V) \equiv \Gamma_1.
\]
\end{theorem}
\begin{proof}
 ($\Rto$) $\forall (\Hm,s_0) \in \Mod(\CTLforget(\varphi, V' \cup V))$\\
 $\Rto$ $\exists (\Hm',s_0') \in \Mod(\varphi)$ s.t. $(\Hm,s_0) \lrto_{V'\cup V} (\Hm', s_0')$\\
 $\Rto$ $\exists (\Hm_1, s_1) \in \Mod(\Elm (\Sub((T_{\varphi}^{r,V \cup V'})', V)_{CTL}, V \cup V'))$ s.t. $(\Hm_1,s_1) \lrto_{V'\cup V} (\Hm', s_0')$\\
 $\Rto$ $(\Hm,s_0) \lrto_{V'\cup V} (\Hm_1,s_1)$\\
 $\Rto$ $(\Hm,s_0) \models \Elm (\Sub((T_{\varphi}^{r,V \cup V'})', V)_{CTL}, V \cup V')$ \hfill ($\IR(\Elm (\Sub((T_{\varphi}^{r,V \cup V'})', V)_{CTL}, V \cup V'), V' \cup V)$)

 ($\Lto$)$\forall (\Hm_1, s_1) \in \Mod(\Elm (\Sub((T_{\varphi}^{r,V \cup V'})', V)_{CTL}, V \cup V'))$\\
 $\Rto$ $\exists (\Hm',s_0') \in \Mod(\varphi)$ s.t. $(\Hm_1,s_1) \lrto_{V'\cup V} (\Hm', s_0')$ \\
 $\Rto$ $(\Hm_1, s_1) \models \CTLforget(\varphi, V' \cup V)$ \hfill ($\IR(\CTLforget(\varphi, V' \cup V), V \cup V')$ and $\varphi \models \CTLforget(\varphi, V' \cup V)$)
\end{proof}

Then we have the following result:
\begin{theorem}\label{thm:Res_based:CTLforget}
\textbf{(Resolution-based CTL-forgetting)}
Let $V''=V \cup V'$, $\Gamma=\Sub(T_{\varphi}^{r, V''}, V')$ and $\Gamma_1=R(\NI(\Elm(\EXIST\FUTURE(\Gamma), \Gamma)))_{\CTL}$, then
\[
\CTLforget(\varphi, V) \equiv \bigwedge_{\psi \in \Gamma_1} \psi.
\]
\end{theorem}

We can obtain that $\CTLforget(\varphi, V) \equiv \CTLforget(\varphi, V' \cup V)$ by Theorem~\ref{thm:Res_based:V_CTLforget}, Proposition~\ref{pro:IR_V:forget} and Proposition~\ref{disTF}. Therefore, the Theorem~\ref{thm:Res_based:CTLforget} is proved.

Then we can obtain the result of forgetting of Example~\ref{exa:until:sub}:
\begin{align*}
& \CTLforget(\varphi, \{p\}) \equiv r\wedge (f\vee m \vee q) \wedge \\
&  (f\vee m \vee (q\wedge \ALL\NEXT(f\vee m\vee q))) \wedge \ALL\GLOBAL((q\wedge \ALL\NEXT(f\vee m\vee q)  \\
& \supset \ALL\NEXT(f\vee m \vee (q\wedge \ALL\NEXT(f\vee m\vee q))))).
\end{align*}


\begin{proposition}
Let $\varphi$ be a CTL formula and $V \subseteq \Ha$.
The time and space complexity of Algorithm~\ref{alg:compute:forgetting:by:Resolution} are $O((m+1)2^{4(n+n')}$. Where $|\Var(\varphi)|=n$, $|V'|=n'$ ($V'$ is set of atoms introduced in transformation) and $m$ is the number of the set $Ind$ of indices introduced during transformation.
\end{proposition}
\begin{proof}
It follows from that the lines 19-31 of the algorithm, which is to compute all the possible resolution.
The possible number of $\CTLsnf$ clauses under the give $V$, $V'$ and $Ind$ is $(m+1)2^{4(n+n')}+(m*(n+n')+n+n'+1)2^{2(n+n')+1})$.
\end{proof}


%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
 \bibliographystyle{splncs04}
 \bibliography{ijcai20}
%
\begin{thebibliography}{8}
\bibitem{ref_article1}
Author, F.: Article title. Journal \textbf{2}(5), 99--110 (2016)

\bibitem{ref_lncs1}
Author, F., Author, S.: Title of a proceedings paper. In: Editor,
F., Editor, S. (eds.) CONFERENCE 2016, LNCS, vol. 9999, pp. 1--13.
Springer, Heidelberg (2016). \doi{10.10007/1234567890}

\bibitem{ref_book1}
Author, F., Author, S., Author, T.: Book title. 2nd edn. Publisher,
Location (1999)

\bibitem{ref_proc1}
Author, A.-B.: Contribution title. In: 9th International Proceedings
on Proceedings, pp. 1--2. Publisher, Location (2010)

\bibitem{ref_url1}
LNCS Homepage, \url{http://www.springer.com/lncs}. Last accessed 4
Oct 2017
\end{thebibliography}
\end{document}
